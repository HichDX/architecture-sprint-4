# Анализ системы и определение кешируемых частей
* Анализ диаграммы системы:

+ В рамках существующей системы MES наблюдаются проблемы с производительностью, что негативно сказывается на пользователях и новых клиентах. 

* На основании анализа предлагается закешировать следующее:
    + Список заказов: Часто запрашиваемая информация, не подвержена частым изменениям.
    + Статусы заказов: Информация, которая обновляется не так часто, её кеширование снизит нагрузку на сервер.
    + Данные о товарах: Информация о журналах товаров, их характеристиках и наличии.
    + Информация о клиентах: Данные профилей клиентов, которые не меняются слишком часто.

# Мотивация

* Кеширование поможет значительно ускорить доступ к часто запрашиваемым данным и тем самым улучшить производительность системы MES. Основные проблемы, которые будут решены:

    + Снижение времени отклика системы: Быстрый доступ к данным из кеша вместо обращений к базе данных.
    + Уменьшение нагрузки на сервер: Меньшее количество запросов к базе данных освободит ресурсы сервера для выполнения других задач.
    + Повышение удовлетворенности пользователей: Быстрый доступ к необходимой информации повысит опыт работы с системой.

* Элементы системы для кеширования:

    + Списки заказов и их статусы.
    + Данные о товарах.
    + Информация о клиентах.

# Предлагаемое решение

* Тип кеширования:

    + Рекомендуется использовать серверное кеширование. Оно подходит лучше, чем клиентское, поскольку:
        - Обеспечивает единообразие данных.
        - Легче управлять и обновлять кеш на серверной стороне.
        - Упрощает процесс масштабирования системы.

* Паттерн кеширования:
    + Выбор паттерна Cache-Aside. Он будет использоваться по следующим причинам:
        - Гибкость: Позволяет коду контролировать, как и когда использовать кеш.
        - Снижение вероятности устаревания данных: Приложение будет самостоятельно запрашивать и обновлять кеш.
        - Простота внедрения: Легче измерить, какие данные кешируются, и управлять ими.

    + Почему другие паттерны не подходят:
        - Write-Through: Компрометирует производительность из-за постоянного обращения к базе данных при каждое изменение данных.
        - Refresh-Ahead: Сложный в управлении и может привести к устаревшим данным, в частности, если частота обновления не совпадает с изменениями в базе.

# Диаграмма последовательности действий (Sequence diagram)

    Клиент → Системный сервис: Запрос списка заказов
    Системный сервис → Кеш: Проверка наличия данных в кеше
    alt Кешированная информация существует
      Кеш → Системный сервис: Возврат данных из кеша
      Системный сервис → Клиент: Ответ с данными из кеша
    else Кеш пуст
      Системный сервис → БД: Запрос списка заказов
      БД → Системный сервис: Возврат данных
      Системный сервис → Кеш: Сохранение данных для кеша
      Системный сервис → Клиент: Ответ с данными
    end
    
    Клиент → Системный сервис: Запрос обновления статуса заказа
    Системный сервис → БД: Запись о новом статусе
    БД → Системный сервис: Подтверждение обновления
    alt Клиент отменяет запрос
        Клиент → Системный сервис: Отмена запроса на обновление статуса
        Системный сервис → БД: Статус изменится на сервере
        БД → Системный сервис: Подтверждение изменения статуса в БД
        Системный сервис → Кеш: Инвалидировать кеш для статусов заказов
    else Запрос выполнен
        Системный сервис → Кеш: Обновление кеша для статусов заказов
    end

# Стратегия инвалидации кеша
* Варианты стратегии инвалидации:
    + Временная инвалидация: Устанавливаем таймер, после которого кеш считается устаревшим.
    + Инвалидация по ключу: Кеш будет инвалидироваться при обновлении определенных данных, что поможет поддерживать актуальность.

* Выбор стратегии:
    + Предлагается использовать инвалидацию по ключу. Она позволит:
        - Поддерживать актуальность кеша, обновляя его только при изменении связанной информации.
        - Избежать устаревших данных, так как кеш будет инвалидироваться только при реальных изменениях.

    + Почему временная инвалидация не подходит:
        - Могут возникать случаи, когда актуальные данные будут удаляться слишком рано.
        - Это может привести к ненужным запросам к базе данных, когда данные все ещё актуальны.


